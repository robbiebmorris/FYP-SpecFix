{"task_id": "Mbpp/2", "requirement": "from typing import List\nfrom typing import Tuple\n\n\ndef similar_elements(test_tup1: List[int], test_tup2: List[int]) -> Tuple[int, ...]:\n\"\"\"\nWrite a function to find the shared elements from the given two lists.\n\"\"\"", "entry_point": "similar_elements", "canonical_solution": "def similar_elements(test_tup1, test_tup2):\n  return tuple(set(test_tup1) & set(test_tup2))", "input_output_examples": "[[[[3, 4, 5, 6], [5, 7, 4, 10]]], [[(4, 5)]]]", "starter_code": "from typing import List\nfrom typing import Tuple\ndef similar_elements(test_tup1: List[int], test_tup2: List[int]) -> Tuple[int, ...]:", "llm_generated_inputs": {"deepseek-v3": "[[[3, 4, 5, 6], [5, 7, 4, 10]], [[1, 2, 3], [4, 5, 6]], [[], [1, 2, 3]], [[1, 1, 2, 3], [2, 3, 3, 4]], [[7, 7, 7, 7], [7, 7, 8, 9]], [[10, 20, 30], [10, 20, 30]], [[1, 2, 3], [1, 2, 3, 4, 5]]]", "qwen2.5-coder-32b-instruct": "[[[3, 4, 5, 6], [5, 7, 4, 10]], [[1, 2, 3], [4, 5, 6]], [[1, 1, 2, 2], [2, 2, 3, 3]], [[], [1, 2, 3]], [[1, 2, 3], []], [[], []], [[1, 2, 3, 4, 5], [5, 4, 3, 2, 1]], [[10, 20, 30, 40], [40, 30, 20, 10]]]", "gpt-4o-mini": "[[[1, 2, 3], [3, 4, 5]], [[1, 1, 2, 3], [3, 2, 1, 1]], [[], [1, 2, 3]], [[1, 2, 3], []], [[], []], [[1, 2, 3], [1, 2, 3]], [[5, 6, 7], [1, 2, 3]], [[1, 2, 3, 4, 5], [3, 4, 5, 6, 7]], [[1, 2, 3], [1, 1, 2, 2, 3, 3]]]"}}
{"task_id": "Mbpp/3", "requirement": "def is_not_prime(n: int) -> bool:\n\"\"\"\nWrite a python function to identify non-prime numbers.\n\"\"\"", "entry_point": "is_not_prime", "canonical_solution": "import math\ndef is_not_prime(n):\n    if n == 1:\n        return True\n    for i in range(2, int(math.sqrt(n))+1):\n        if n % i == 0:\n            return True\n    return False", "input_output_examples": "[[[2]], [[False]]]", "starter_code": "def is_not_prime(n: int) -> bool:", "llm_generated_inputs": {"deepseek-v3": "[[2], [3], [4], [1], [0], [-7], [29], [30], [100]]", "qwen2.5-coder-32b-instruct": "[[2], [3], [4], [5], [9], [11], [15], [17], [18], [19], [20], [23], [24], [25], [29], [30], [-1], [0], [1]]", "gpt-4o-mini": "[[1], [4], [6], [9], [10], [12], [15], [16], [20], [25], [0], [-3], [100], [37]]"}}
{"task_id": "Mbpp/4", "requirement": "def heap_queue_largest(nums: list, n: int) -> list:\n\"\"\"\nWrite a function to find the n largest integers from a given list of numbers, returned in descending order.\n\n\n\"\"\"", "entry_point": "heap_queue_largest", "canonical_solution": "import heapq as hq\ndef heap_queue_largest(nums: list,n: int) -> list:\n  largest_nums = hq.nlargest(n, nums)\n  return largest_nums", "input_output_examples": "[[[[25, 35, 22, 85, 14, 65, 75, 22, 58], 3]], [[[85, 75, 65]]]]", "starter_code": "def heap_queue_largest(nums: list, n: int) -> list:", "llm_generated_inputs": {"deepseek-v3": "[[[25, 35, 22, 85, 14, 65, 75, 22, 58], 3], [[1, 2, 3, 4, 5], 2], [[10, 20, 30, 40, 50], 5], [[5, 5, 5, 5, 5], 1], [[], 0], [[7], 1], [[100, 200, 300, 400], 0], [[-5, -1, -3, -2, -4], 2]]", "qwen2.5-coder-32b-instruct": "[[[25, 35, 22, 85, 14, 65, 75, 22, 58], 3], [[1, 2, 3, 4, 5], 5], [[10, 9, 8, 7, 6, 5, 4, 3, 2, 1], 1], [[5, 5, 5, 5, 5], 3], [[100], 1], [[100, 200, 300], 0], [[100, 200, 300], 5], [[], 3], [[1, 2, 3], -1]]", "gpt-4o-mini": "[[[3, 1, 4, 1, 5, 9], 3], [[10, 20, 30, 40, 50], 2], [[1, 2, 3], 1], [[-10, -20, -30, -5], 2], [[1], 1], [[], 0], [[10, 20, 30, 20, 10], 5], [[5, 5, 5, 5], 3], [[1, 2, 3, 4, 5], 6]]"}}
{"task_id": "Mbpp/6", "requirement": "def differ_At_One_Bit_Pos(a: int, b: int) -> bool:\n\"\"\"\nWrite a python function to check whether the two numbers differ at one bit position only or not.\n\"\"\"", "entry_point": "differ_At_One_Bit_Pos", "canonical_solution": "def is_Power_Of_Two(x: int): \n    return x > 0 and (x & (x - 1)) == 0\ndef differ_At_One_Bit_Pos(a: int,b: int):\n    return is_Power_Of_Two(a ^ b)", "input_output_examples": "[[[13, 9]], [[True]]]", "starter_code": "def differ_At_One_Bit_Pos(a: int, b: int) -> bool:", "llm_generated_inputs": {"deepseek-v3": "[[13, 9], [1, 0], [15, 7], [0, 1], [255, 254], [1023, 1015], [8, 0], [4095, 4094], [123, 122], [123, 125]]", "qwen2.5-coder-32b-instruct": "[[13, 9], [0, 1], [2, 3], [4, 5], [8, 10], [1, 2], [3, 1], [15, 7], [31, 15], [16, 0], [0, 0], [5, 5], [255, 254], [1024, 1025], [2048, 2049]]", "gpt-4o-mini": "[[5, 7], [2, 3], [8, 12], [15, 14], [0, 1], [1, 0], [0, 0], [3, 2]]"}}
{"task_id": "Mbpp/7", "requirement": "from typing import List\n\n\ndef find_char_long(text: str) -> List[str]:\n\"\"\"\nWrite a function to find all words which are at least 4 characters long in a string.\n\"\"\"", "entry_point": "find_char_long", "canonical_solution": "import re\ndef find_char_long(text):\n  return (re.findall(r\"\\b\\w{4,}\\b\", text))", "input_output_examples": "[[['Please move back to stream']], [[['Please', 'move', 'back', 'stream']]]]", "starter_code": "from typing import List\ndef find_char_long(text: str) -> List[str]:", "llm_generated_inputs": {"deepseek-v3": "[['Please move back to stream'], ['hello world'], ['hi there'], ['a b c d'], [''], ['    '], ['This is a test string with punctuation, like periods. And commas!'], ['1234 567 8901'], ['LongWordWithNoSpaces'], ['a'], ['   extra   spaces   ']]", "qwen2.5-coder-32b-instruct": "[['Please move back to stream'], ['a'], ['abc'], ['abcd'], ['abcde'], ['This is a test string with some longwordsindeed'], ['short longword'], ['equal equal'], ['single'], ['multiple words here'], ['1234 56789'], ['!@#$%^ &*()'], ['MixedCASE Words'], ['1234abcd efgh5678'], ['boundary conditions']]", "gpt-4o-mini": "[['This is a test string with several words'], ['Short nope'], ['Python programming is fun'], ['Four four four'], ['A quick brown fox jumps over the lazy dog'], [''], ['abcd efgh ijkl mnop'], ['singleword']]"}}
{"task_id": "Mbpp/8", "requirement": "from typing import List\n\n\ndef square_nums(nums: List[int]) -> List[int]:\n\"\"\"\nWrite a function to find squares of individual elements in a list.\n\"\"\"", "entry_point": "square_nums", "canonical_solution": "def square_nums(nums):\n return [i**2 for i in nums]", "input_output_examples": "[[[[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]]], [[[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]]]]", "starter_code": "from typing import List\ndef square_nums(nums: List[int]) -> List[int]:", "llm_generated_inputs": {"deepseek-v3": "[[[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]], [[0]], [[-1, -2, -3, -4]], [[100, 200, 300]], [[]], [[1, 0, -1]]]", "qwen2.5-coder-32b-instruct": "[[[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]], [[0]], [[-1, -2, -3]], [[10, 20, 30]], [[]], [[100, 200, 300]], [[1, 0, -1, 2, -2]]]", "gpt-4o-mini": "[[[1, 2, 3]], [[4, 5, 6]], [[-1, -2, -3]], [[0]], [[5]], [[1, -1, 0]], [[100, 200, 300]], [[2, 2, 2]], [[-5, 0, 5]], [[-10, 10]], [[3, 1, 4, 1, 5]]]"}}
{"task_id": "Mbpp/9", "requirement": "def find_Rotations(s: str) -> int:\n\"\"\"\nWrite a python function to find the minimum number of rotations (greater than 0) required to get the same string.\n\"\"\"", "entry_point": "find_Rotations", "canonical_solution": "def find_Rotations(s): \n    n = len(s)\n    s += s\n    for i in range(1, n + 1):\n        if s[i: i + n] == s[0: n]:\n            return i\n    return n", "input_output_examples": "[[['aaaa']], [[1]]]", "starter_code": "def find_Rotations(s: str) -> int:", "llm_generated_inputs": {"deepseek-v3": "[['aaaa'], ['abab'], ['abcabcabc'], ['a'], ['abcdef'], ['abacabadabacabad'], ['xyzxyzxyzxyz'], ['ababababab'], ['ababababc'], ['aabbccddeeff']]", "qwen2.5-coder-32b-instruct": "[['aaaa'], ['abcde'], ['abab'], ['abcdabcd'], ['aabbccdd'], ['zzzzzzzz'], ['abcdefg'], ['a'], ['']]", "gpt-4o-mini": "[['abcabc'], ['abcd'], ['aaaa'], ['a'], ['abcdeabc'], [''], ['rotate'], ['aaabaaa'], ['abca']]"}}
{"task_id": "Mbpp/11", "requirement": "def remove_Occ(s: str, ch: str) -> str:\n\"\"\"\nWrite a python function to remove first and last occurrence of a given character from the string.\n\n\n\"\"\"", "entry_point": "remove_Occ", "canonical_solution": "def remove_Occ(s,ch): \n    s = s.replace(ch, '', 1)\n    s = s[::-1].replace(ch, '', 1)[::-1]\n    return s", "input_output_examples": "[[['hello', 'l']], [['heo']]]", "starter_code": "def remove_Occ(s: str, ch: str) -> str:", "llm_generated_inputs": {"deepseek-v3": "[['hello', 'l'], ['banana', 'a'], ['mississippi', 's'], ['racecar', 'r'], ['example', 'e'], ['programming', 'm'], ['python', 'y'], ['hello', 'o'], ['hello', 'h'], ['hello', 'x'], ['', 'a'], ['a', 'a'], ['aa', 'a'], ['aaa', 'a'], ['abab', 'a'], ['abab', 'b']]", "qwen2.5-coder-32b-instruct": "[['hello', 'l'], ['abracadabra', 'a'], ['mississippi', 'i'], ['foobar', 'f'], ['foobar', 'x'], ['', 'a'], ['a', 'a'], ['aaaa', 'a'], ['abcde', 'e'], ['abcde', 'a']]", "gpt-4o-mini": "[['hello', 'l'], ['ababab', 'a'], ['abcdef', 'g'], ['', 'a'], ['a', 'a'], ['hello world', 'o'], ['mississippi', 'i'], ['aabbcc', 'b']]"}}
{"task_id": "Mbpp/12", "requirement": "from typing import List\n\n\ndef sort_matrix(matrix: List[List[int]]) -> List[List[int]]:\n\"\"\"\nWrite a function to sort a given matrix in ascending order according to the sum of its rows.\n\"\"\"", "entry_point": "sort_matrix", "canonical_solution": "def sort_matrix(M):\n    result = sorted(M, key=sum)\n    return result", "input_output_examples": "[[[[[1, 2, 3], [2, 4, 5], [1, 1, 1]]]], [[[[1, 1, 1], [1, 2, 3], [2, 4, 5]]]]]", "starter_code": "from typing import List\ndef sort_matrix(matrix: List[List[int]]) -> List[List[int]]:", "llm_generated_inputs": {"deepseek-v3": "[[[[1, 2, 3], [2, 4, 5], [1, 1, 1]]], [[[5, 3], [1, 4], [2, 2]]], [[[-1, -2, -3], [-2, -4, -5], [-1, -1, -1]]], [[[], []]], [[[1]]], [[[3, 2, 1], [1, 2, 3], [1, 1, 1]]], [[[10, 20], [5, 15], [1, 1]]], [[[0, 0], [0, 0], [0, 0]]], [[[1, 2], [3, 4], [5, 6]]], [[[7, 8, 9], [1, 2, 3], [4, 5, 6]]]]", "qwen2.5-coder-32b-instruct": "[[[[1, 2, 3], [2, 4, 5], [1, 1, 1]]], [[[10, 15], [5, 20], [25, 0]]], [[[5, 5, 5], [0, 0, 0], [1, 2, 3]]], [[[3, 2, 1], [6, 5, 4], [9, 8, 7]]], [[]], [[[]]], [[[1]]], [[[1, 2], [3, 4], [5, 6], [7, 8]]]]", "gpt-4o-mini": "[[[[3, 2, 1], [1, 2, 3], [0, 0, 0]]], [[[5, 5, 5], [6, 6, 6], [1, 1, 1]]], [[[1, 2], [3, 4], [5, 6]]], [[[7]]], [[[2, 2, 2], [1, 1, 1], [3, 3, 3]]], [[[]]], [[[2], [1], [3]]], [[[4, 5], [1, 1], [2, 2]]], [[[0, -1], [-2, 2], [-1, 1]]]]"}}
{"task_id": "Mbpp/14", "requirement": "def find_Volume(l: float, b: float, h: float) -> float:\n\"\"\"\nWrite a python function to find the volume of a triangular prism.\n\"\"\"", "entry_point": "find_Volume", "canonical_solution": "def find_Volume(l,b,h) : \n    return ((l * b * h) / 2)", "input_output_examples": "[[[10, 8, 6]], [[240]]]", "starter_code": "def find_Volume(l: float, b: float, h: float) -> float:", "llm_generated_inputs": {"deepseek-v3": "[[10.0, 8.0, 6.0], [0.0, 8.0, 6.0], [10.0, 0.0, 6.0], [10.0, 8.0, 0.0], [-10.0, 8.0, 6.0], [10.0, -8.0, 6.0], [10.0, 8.0, -6.0], [1.5, 2.5, 3.5], [1000000.0, 1000000.0, 1000000.0], [1e-06, 1e-06, 1e-06]]", "qwen2.5-coder-32b-instruct": "[[10, 8, 6], [0, 5, 10], [5, 0, 10], [5, 10, 0], [0, 0, 0], [1.5, 2.5, 3.5], [-1, 5, 10], [5, -1, 10], [5, 10, -1], [-1, -1, -1]]", "gpt-4o-mini": "[[5.0, 3.0, 10.0], [2.5, 4.0, 6.0], [0.0, 5.0, 7.0], [-3.0, 3.0, 5.0], [3.0, 4.0, 0.0], [1.5, 2.5, 2.0], [10.0, 10.0, 10.0], [7.5, 12.0, 1.0]]"}}
{"task_id": "Mbpp/16", "requirement": "def text_lowercase_underscore(text: str) -> bool:\n\"\"\"\nWrite a function to that returns true if the input string contains sequences of lowercase letters joined with an underscore and false otherwise.\n\"\"\"", "entry_point": "text_lowercase_underscore", "canonical_solution": "import re\ndef text_lowercase_underscore(text):\n        return bool(re.match('^[a-z]+(_[a-z]+)*$', text))", "input_output_examples": "[[['aab_cbbbc']], [[True]]]", "starter_code": "def text_lowercase_underscore(text: str) -> bool:", "llm_generated_inputs": {"deepseek-v3": "[['aab_cbbbc'], ['abc_def_ghi'], ['abc_def_ghi_jkl'], ['abc_123_def'], ['ABC_DEF'], ['abc_def_ghi_'], ['_abc_def'], ['abc__def'], [''], ['abc'], ['a_b_c']]", "qwen2.5-coder-32b-instruct": "[['aab_cbbbc'], ['Aab_cbbbc'], ['aab_Cbbbc'], ['aab_cbbBc'], ['aab_cbbbc_'], ['_aab_cbbbc'], ['aab__cbbbc'], ['aab_cbbbc_def'], ['aab_cbbbc123'], ['123_aab_cbbbc'], ['aab_cbbbc!'], ['aab_cbbbc '], [''], ['_'], ['a_b_c_d_e'], ['abcdefghijklmnopqrstuvwxyz'], ['a_b']]", "gpt-4o-mini": "[['abc_def'], [('abc_def_gh',)], ['abcDef'], ['abc__def'], ['ABC_def'], [('abc',)], [('abc_123',)], [('def_ghi_jkl',)], [('def_GHI',)], [('1_abc',)], [('a_b_c',)]]"}}
{"task_id": "Mbpp/17", "requirement": "def square_perimeter(a: int) -> int:\n\"\"\"\nWrite a function that returns the perimeter of a square given its side length as input.\n\"\"\"", "entry_point": "square_perimeter", "canonical_solution": "def square_perimeter(a):\n  return 4*a", "input_output_examples": "[[[10]], [[40]]]", "starter_code": "def square_perimeter(a: int) -> int:", "llm_generated_inputs": {"deepseek-v3": "[[10], [0], [1], [100], [-5]]", "qwen2.5-coder-32b-instruct": "[[10], [0], [1], [-5], [100]]", "gpt-4o-mini": "[[1], [0], [-5], [10], [100], [1000]]"}}
{"task_id": "Mbpp/18", "requirement": "def remove_dirty_chars(string: str, second_string: str) -> str:\n\"\"\"\nWrite a function to remove characters from the first string which are present in the second string.\n\n\n\"\"\"", "entry_point": "remove_dirty_chars", "canonical_solution": "def remove_dirty_chars(string, second_string): \n\tfor char in second_string:\n\t\tstring = string.replace(char, '')\n\treturn string", "input_output_examples": "[[['probasscurve', 'pros']], [['bacuve']]]", "starter_code": "def remove_dirty_chars(string: str, second_string: str) -> str:", "llm_generated_inputs": {"deepseek-v3": "[['probasscurve', 'pros'], ['hello world', 'aeiou'], ['12345', '135'], ['abcde', ''], ['', 'abc'], ['abcABC', 'aB'], ['@#$%^&', '@%'], ['same', 'same'], ['different', 'xyz'], ['spaces and tabs', ' \\t']]", "qwen2.5-coder-32b-instruct": "[['probasscurve', 'pros'], ['hello', 'aeiou'], ['abcdef', 'ghijkl'], ['', 'abc'], ['abc', ''], ['', ''], ['aabbcc', 'abc'], ['python', 'nohtyp'], ['12345', '54321'], ['special!@#', '!@']]", "gpt-4o-mini": "[['hello world', 'ow'], ['python programming', 'pgn'], ['remove dirty chars', 'rty'], ['case sensitive', 'abc'], ['12345', '246'], ['', 'abc'], ['hello', ''], ['abcdef', 'abcdef'], ['', ''], ['aabbcc', 'abc']]"}}
{"task_id": "Mbpp/19", "requirement": "from typing import List\n\n\ndef test_duplicate(arraynums: List[int]) -> bool:\n\"\"\"\nWrite a function to find whether a given array of integers contains any duplicate element.\n\"\"\"", "entry_point": "test_duplicate", "canonical_solution": "def test_duplicate(arraynums):\n    return len(arraynums) != len(set(arraynums))", "input_output_examples": "[[[[1, 2, 3, 4, 5]]], [[False]]]", "starter_code": "from typing import List\ndef test_duplicate(arraynums: List[int]) -> bool:", "llm_generated_inputs": {"deepseek-v3": "[[[1, 2, 3, 4, 5]], [[1, 2, 3, 4, 1]], [[]], [[1]], [[1, 1]], [[1, 2, 3, 2, 4]], [[10, 20, 30, 20, 40]]]", "qwen2.5-coder-32b-instruct": "[[[1, 2, 3, 4, 5]], [[1, 2, 2, 3, 4]], [[]], [[10]], [[1, 1, 1, 1, 1]], [[1, 2, 3, 4, 4, 5, 6, 7, 8, 9, 10]], [[100, 200, 300, 400, 500, 100]], [[-1, -2, -3, -4, -5, -1]], [[0, 0, 0, 0]]]", "gpt-4o-mini": "[[[1, 2, 3, 4, 5]], [[1, 2, 3, 2, 4]], [[0, -1, 1, -1]], [[10, 20, 30, 40, 50, 10]], [[]], [[1]], [[3, 3, 3, 3]], [[1, 1, 2, 2, 3, 3]]]"}}
{"task_id": "Mbpp/20", "requirement": "def is_woodall(num: int) -> bool:\n\"\"\"\nWrite a function to check if the given number is woodall or not.\n\"\"\"", "entry_point": "is_woodall", "canonical_solution": "def is_woodall(x): \n\tif not isinstance(x, int):\n\t\treturn False\n\tif x <= 0 or x % 2 == 0:\n\t\treturn False\n\tif (x == 1): \n\t\treturn True\n\tx += 1 \n\ti = 0\n\twhile (x % 2 == 0): \n\t\tx /= 2\n\t\ti += 1\n\t\tif (i == x): \n\t\t\treturn True\n\treturn False", "input_output_examples": "[[[383]], [[True]]]", "starter_code": "def is_woodall(num: int) -> bool:", "llm_generated_inputs": {"deepseek-v3": "[[383], [1], [7], [23], [63], [159], [100], [0], [-1]]", "qwen2.5-coder-32b-instruct": "[[0], [1], [2], [7], [23], [383], [319], [-5], [-1], [1000]]", "gpt-4o-mini": "[[1], [2], [3], [4], [5], [7], [15], [9], [8], [13], [10], [27], [36], [0], [-1], [100]]"}}
{"task_id": "Mbpp/56", "requirement": "def check(n: int) -> bool:\n\"\"\"\nWrite a python function to check if a given number is one less than twice its reverse.\n\"\"\"", "entry_point": "check", "canonical_solution": "def check(n):    \n    return n == 2 * int(str(n)[::-1]) - 1", "input_output_examples": "[[[70]], [[False]]]", "starter_code": "def check(n: int) -> bool:", "llm_generated_inputs": {"deepseek-v3": "[[70], [37], [0], [1], [100], [123], [53], [999]]", "qwen2.5-coder-32b-instruct": "[[70], [21], [0], [1], [9], [10], [11], [12], [23], [55], [99], [100], [201], [-1], [-21]]", "gpt-4o-mini": "[[12], [21], [0], [1], [9], [10], [99], [101], [1001], [200]]"}}
{"task_id": "Mbpp/57", "requirement": "from typing import List\n\n\ndef find_Max_Num(arr: List[int]) -> int:\n\"\"\"\nWrite a python function to find the largest number that can be formed with the given list of digits.\n\"\"\"", "entry_point": "find_Max_Num", "canonical_solution": "def find_Max_Num(arr) : \n    arr.sort(reverse = True)\n    return int(\"\".join(map(str,arr)))", "input_output_examples": "[[[[1, 2, 3]]], [[321]]]", "starter_code": "from typing import List\ndef find_Max_Num(arr: List[int]) -> int:", "llm_generated_inputs": {"deepseek-v3": "[[[1, 2, 3]], [[9, 8, 7, 6]], [[0, 0, 0]], [[5]], [[1, 0, 2, 9]], [[9, 9, 9, 9]], [[4, 3, 2, 1, 0]], [[1, 3, 2, 1, 3]], [[8, 7, 6, 5, 4, 3, 2, 1]], [[0, 1, 0, 1, 0]]]", "qwen2.5-coder-32b-instruct": "[[[1, 2, 3]], [[3, 2, 1]], [[0, 0, 0]], [[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]], [[1]], [[5, 5, 5, 5]], [[9, 9, 8, 8, 7, 7, 6, 6]], [[10, 20, 30]]]", "gpt-4o-mini": "[[[3, 30, 34, 5, 9]], [[0, 0, 0]], [[9, 5, 34, 3, 30]], [[1, 2, 3, 4, 5]], [[5]], [[-1, -2, -3]], [[0, 1, 2, 10]], [[2, 22, 223]]]"}}
{"task_id": "Mbpp/58", "requirement": "def opposite_Signs(x: int, y: int) -> bool:\n\"\"\"\nWrite a python function to check whether the given two integers have opposite sign or not.\n\"\"\"", "entry_point": "opposite_Signs", "canonical_solution": "def opposite_Signs(x,y): \n    return ((x ^ y) < 0)", "input_output_examples": "[[[1, -2]], [[True]]]", "starter_code": "def opposite_Signs(x: int, y: int) -> bool:", "llm_generated_inputs": {"deepseek-v3": "[[1, -2], [-1, 2], [0, 0], [0, 5], [-3, 0], [10, 10], [-7, -7], [2147483647, -2147483648], [-2147483648, 2147483647]]", "qwen2.5-coder-32b-instruct": "[[1, -2], [-5, 10], [0, 5], [0, -3], [7, 3], [-8, -4], [100, -100], [-256, 256], [-1, 1]]", "gpt-4o-mini": "[[-5, 5], [0, 10], [-10, 0], [-1, 1], [1, -1], [-42, 42], [-999, 500], [7, -3], [10, -10], [-15, -20]]"}}
{"task_id": "Mbpp/59", "requirement": "def is_octagonal(n: int) -> int:\n\"\"\"\nWrite a function to find the nth octagonal number.\n\"\"\"", "entry_point": "is_octagonal", "canonical_solution": "def is_octagonal(n): \n\treturn 3 * n * n - 2 * n", "input_output_examples": "[[[5]], [[65]]]", "starter_code": "def is_octagonal(n: int) -> int:", "llm_generated_inputs": {"deepseek-v3": "[[1], [2], [3], [5], [10], [0], [-1], [100]]", "qwen2.5-coder-32b-instruct": "[[1], [2], [3], [4], [5], [10], [0], [-1], [100]]", "gpt-4o-mini": "[[1], [2], [3], [4], [5], [0], [-1], [10], [100], [1000]]"}}
{"task_id": "Mbpp/61", "requirement": "def count_Substrings(s: str) -> int:\n\"\"\"\nWrite a python function to count the number of substrings with the sum of digits equal to their length.\n\"\"\"", "entry_point": "count_Substrings", "canonical_solution": "from collections import defaultdict\ndef count_Substrings(s):\n    n, count, sum = len(s), 0, 0\n    mp = defaultdict(lambda : 0)\n    mp[0] += 1\n    for i in range(n):\n        sum += ord(s[i]) - ord('0')\n        count += mp[sum - i - 1]\n        mp[sum - i - 1] += 1\n    return count", "input_output_examples": "[[['112112']], [[6]]]", "starter_code": "def count_Substrings(s: str) -> int:", "llm_generated_inputs": {"deepseek-v3": "[['112112'], ['123'], ['11'], ['1'], ['121212'], ['000'], ['10101'], ['999'], ['']]", "qwen2.5-coder-32b-instruct": "[['112112'], ['000'], ['12345'], ['111'], ['987654321'], [''], ['1'], ['12'], ['11']]", "gpt-4o-mini": "[['123'], ['111'], ['222'], ['12345'], ['000'], ['1'], [''], ['987654321'], ['1111'], ['123321']]"}}
{"task_id": "Mbpp/62", "requirement": "from typing import List\n\n\ndef smallest_num(xs: List[int]) -> int:\n\"\"\"\nWrite a python function to find smallest number in a list.\n\"\"\"", "entry_point": "smallest_num", "canonical_solution": "def smallest_num(xs):\n  assert len(xs) > 0, \"invalid inputs\"\n  return min(xs)", "input_output_examples": "[[[[10, 20, 1, 45, 99]]], [[1]]]", "starter_code": "from typing import List\ndef smallest_num(xs: List[int]) -> int:", "llm_generated_inputs": {"deepseek-v3": "[[[10, 20, 1, 45, 99]], [[5, 4, 3, 2, 1]], [[100, 200, 300, 400, 500]], [[-1, -2, -3, -4, -5]], [[0, 0, 0, 0, 0]], [[]], [[42]], [[1, 1, 1, 1, 1]], [[10, 20, -1, 45, 99]]]", "qwen2.5-coder-32b-instruct": "[[[10, 20, 1, 45, 99]], [[3, 1, 4, 1, 5, 9]], [[0, -1, -2, -3, -4]], [[100]], [[]], [[7, 7, 7, 7]]]", "gpt-4o-mini": "[[[3, 1, 2]], [[10, 5, -1, 0]], [[-5, -1, -10]], [[100, 200, 300]], [[1]], [[]], [[5, 5, 5, 5]]]"}}
{"task_id": "Mbpp/63", "requirement": "from typing import List\nfrom typing import Tuple\n\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n\"\"\"\nWrite a function to find the maximum difference between available pairs in the given tuple list.\n\"\"\"", "entry_point": "max_difference", "canonical_solution": "def max_difference(test_list):\n  return max(abs(a - b) for a, b in test_list)", "input_output_examples": "[[[[(3, 5), (1, 7), (10, 3), (1, 2)]]], [[7]]]", "starter_code": "from typing import List\nfrom typing import Tuple\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:", "llm_generated_inputs": {"deepseek-v3": "[[[(3, 5), (1, 7), (10, 3), (1, 2)]], [[(1, 1)]], [[(10, 1), (5, 5), (7, 3)]], [[]], [[(0, 0), (0, 0)]], [[(100, 50), (200, 150), (300, 250)]], [[(2, 10), (1, 5), (3, 3)]]]", "qwen2.5-coder-32b-instruct": "[[[(3, 5), (1, 7), (10, 3), (1, 2)]], [[(10, 2), (5, 5), (8, 3)]], [[(1, 1), (2, 2), (3, 3)]], [[(-1, -5), (-3, -2), (-4, -8)]], [[(100, 50), (200, 150), (300, 250)]], [[(0, 0)]], [[]]]", "gpt-4o-mini": "[[[(1, 2), (3, 5), (6, 10)]], [[(10, 1), (20, 5), (30, 10)]], [[(0, 0), (0, 0), (0, 0)]], [[(1, 2), (2, 3), (3, 4), (10, 5)]], [[(100, 200), (150, 250), (300, 400)]], [[(1, 10), (10, 1), (5, 5)]]]"}}
{"task_id": "Mbpp/64", "requirement": "from typing import List\nfrom typing import Tuple\n\n\ndef subject_marks(subjectmarks: List[Tuple[str, int]]) -> List[Tuple[str, int]]:\n\"\"\"\nWrite a function to sort a list of tuples using the second value of each tuple.\n\"\"\"", "entry_point": "subject_marks", "canonical_solution": "def subject_marks(subjectmarks):\n#subject_marks = [('English', 88), ('Science', 90), ('Maths', 97), ('Social sciences', 82)])\n subjectmarks.sort(key = lambda x: x[1])\n return subjectmarks", "input_output_examples": "[[[[('English', 88), ('Science', 90), ('Maths', 97), ('Social sciences', 82)]]], [[[('Social sciences', 82), ('English', 88), ('Science', 90), ('Maths', 97)]]]]", "starter_code": "from typing import List\nfrom typing import Tuple\ndef subject_marks(subjectmarks: List[Tuple[str, int]]) -> List[Tuple[str, int]]:", "llm_generated_inputs": {"deepseek-v3": "[[[('English', 88), ('Science', 90), ('Maths', 97), ('Social sciences', 82)]], [[('Physics', 75), ('Chemistry', 85), ('Biology', 80)]], [[('History', 92), ('Geography', 78), ('Economics', 88)]], [[('Art', 95), ('Music', 85), ('Drama', 90)]], [[('Computer Science', 100), ('Mathematics', 99), ('Physics', 98)]], [[('Literature', 70), ('Philosophy', 65), ('Psychology', 75)]], [[('English', 50), ('Maths', 60), ('Science', 55)]], [[('Subject A', 0), ('Subject B', 100), ('Subject C', 50)]], [[('Subject X', 1), ('Subject Y', 2), ('Subject Z', 3)]], [[('Subject P', 100), ('Subject Q', 100), ('Subject R', 100)]], [[]]]", "qwen2.5-coder-32b-instruct": "[[[('English', 88), ('Science', 90), ('Maths', 97), ('Social sciences', 82)]], [[('History', 75), ('Geography', 75), ('Physics', 85)]], [[('Chemistry', 100)]], [[]], [[('Biology', 60), ('Art', 50), ('Music', 40), ('Physical Education', 30)]]]", "gpt-4o-mini": "[[[('Math', 90), ('Science', 85), ('English', 95)]], [[('History', 75), ('Art', 80), ('Geography', 70)]], [[('Biology', 88), ('Chemistry', 92)]], [[('Physics', 100), ('Literature', 80), ('Music', 88)]], [[('PE', 60), ('Math', 60), ('Science', 60)]], [[('Math', 50), ('Math', 100)]], [[('CS', 90)]], [[('English', 85), ('Art', 85), ('History', 85)]]]"}}
{"task_id": "Mbpp/65", "requirement": "from typing import List\nfrom typing import Union\n\n\ndef recursive_list_sum(data_list: List[Union[int, List]]) -> int:\n\"\"\"\nWrite a function to flatten a list and sum all of its elements.\n\"\"\"", "entry_point": "recursive_list_sum", "canonical_solution": "def recursive_list_sum(data_list):\n\ttotal = 0\n\tfor element in data_list:\n\t\tif type(element) == type([]):\n\t\t\ttotal = total + recursive_list_sum(element)\n\t\telse:\n\t\t\ttotal = total + element\n\treturn total", "input_output_examples": "[[[[1, 2, [3, 4], [5, 6]]]], [[21]]]", "starter_code": "from typing import List\nfrom typing import Union\ndef recursive_list_sum(data_list: List[Union[int, List]]) -> int:", "llm_generated_inputs": {"deepseek-v3": "[[[1, 2, [3, 4], [5, 6]]], [[[1, 2], [3, 4], [5, 6]]], [[1, 2, 3, 4, 5, 6]], [[[1, [2, [3, [4, [5, [6]]]]]]]], [[]], [[1]], [[[1]]], [[1, [2, 3], [4, [5, 6, [7, 8, [9]]]]]], [[[], [1, 2], [3, [4, []]]]]]", "qwen2.5-coder-32b-instruct": "[[[1, 2, [3, 4], [5, 6]]], [[1, [2, [3, [4, [5]]]]]], [[]], [[1, 2, 3, 4, 5]], [[[[1]], 2, [3, [4, 5]]]], [[0, [0, [0, [0]]]]], [[[-1, -2, [-3, -4], [-5, -6]]]]]", "gpt-4o-mini": "[[[1, 2, 3]], [[1, [2, 3], 4]], [[[1, 2], [3, 4]]], [[1, [2, [3, 4]], 5]], [[]], [[1, [2, [3, [4, [5]]]]]], [[1, 'two', 3]], [[None, [2, 3]]], [[1, [2, [], [3]], [4]]], [[1.1, 2.2, [3.3], [4.4, [5.5]]]]]"}}
{"task_id": "Mbpp/66", "requirement": "from typing import List\n\n\ndef pos_count(l: List[int]) -> int:\n\"\"\"\nWrite a python function to count the number of positive numbers in a list.\n\"\"\"", "entry_point": "pos_count", "canonical_solution": "def pos_count(l):\n  return len([x for x in l if x > 0])", "input_output_examples": "[[[[1, -2, 3, -4]]], [[2]]]", "starter_code": "from typing import List\ndef pos_count(l: List[int]) -> int:", "llm_generated_inputs": {"deepseek-v3": "[[[1, -2, 3, -4]], [[0, 0, 0, 0]], [[]], [[5, 10, 15, 20]], [[-1, -2, -3, -4]], [[1, 2, 3, -1, -2, -3]], [[100, -100, 200, -200]], [[0, 1, -1, 2, -2]]]", "qwen2.5-coder-32b-instruct": "[[[1, -2, 3, -4]], [[0, 0, 0, 0]], [[1, 2, 3, 4]], [[-1, -2, -3, -4]], [[]], [[1]], [[-1]], [[0]], [[1, -1, 0]], [[100, 200, 300]], [[-100, -200, -300]]]", "gpt-4o-mini": "[[[1, -2, 3, 4, 0]], [[-1, -2, -3, -4]], [[0]], [[2, 3, 5, 7, 11]], [[10, -5, -10, 15, 0]], [[100, 200, 300]], [[-5, -15, -25, -35]], [[0, 0, 0]], [[1, 2, 3, 4, 5, 6]], [[-1, 2, -3, 4, -5]]]"}}
{"task_id": "Mbpp/67", "requirement": "def bell_number(n: int) -> int:\n\"\"\"\nWrite a function to find the number of ways to partition a set of Bell numbers.\n\"\"\"", "entry_point": "bell_number", "canonical_solution": "def bell_number(n):   \n    bell = [[0 for i in range(n+1)] for j in range(n+1)] \n    bell[0][0] = 1\n    for i in range(1, n+1): \n        bell[i][0] = bell[i-1][i-1]  \n        for j in range(1, i+1): \n            bell[i][j] = bell[i-1][j-1] + bell[i][j-1]   \n    return bell[n][0]", "input_output_examples": "[[[2]], [[2]]]", "starter_code": "def bell_number(n: int) -> int:", "llm_generated_inputs": {"deepseek-v3": "[[0], [1], [2], [3], [5], [10]]", "qwen2.5-coder-32b-instruct": "[[0], [1], [2], [3], [4], [5], [6], [7], [8], [9], [10]]", "gpt-4o-mini": "[[0], [1], [2], [3], [10], [20], [100]]"}}
{"task_id": "Mbpp/68", "requirement": "from typing import List\n\n\ndef is_Monotonic(arr: List[int]) -> bool:\n\"\"\"\nWrite a python function to check whether the given array is monotonic or not.\n\"\"\"", "entry_point": "is_Monotonic", "canonical_solution": "def is_Monotonic(A): \n    return all(a <= b for a, b in zip(A, A[1:])) or all(a >= b for a, b in zip(A, A[1:]))", "input_output_examples": "[[[[6, 5, 4, 4]]], [[True]]]", "starter_code": "from typing import List\ndef is_Monotonic(arr: List[int]) -> bool:", "llm_generated_inputs": {"deepseek-v3": "[[[6, 5, 4, 4]], [[1, 2, 3, 4, 5]], [[1, 1, 1, 1]], [[]], [[1]], [[3, 3, 2, 1]], [[1, 2, 2, 3, 4]], [[1, 3, 2, 4]], [[5, 5, 5, 5, 5]], [[10, 9, 8, 7, 6, 5, 4, 3, 2, 1]], [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]], [[1, 2, 3, 2, 1]]]", "qwen2.5-coder-32b-instruct": "[[[6, 5, 4, 4]], [[1, 2, 2, 3]], [[1, 3, 2]], [[1, 2, 4, 5]], [[1, 1, 1]], [[5, 5, 5, 5]], [[10]], [[]], [[7, 7, 7, 8, 9, 10]], [[10, 9, 8, 8, 7, 6]]]", "gpt-4o-mini": "[[[1, 2, 2, 3]], [[6, 5, 4, 4]], [[1, 3, 2]], [[1, 1, 1]], [[-1, -2, -3, -4]], [[1, 2, 3, 4, 5]], [[5, 4, 3, 2, 1]], [[1]], [[]], [[1, 2, 3, 4, 2]]]"}}
{"task_id": "Mbpp/69", "requirement": "from typing import List\n\n\ndef is_sublist(l: List[int], s: List[int]) -> bool:\n\"\"\"\nWrite a function to check whether a list contains the given sublist or not.\n\"\"\"", "entry_point": "is_sublist", "canonical_solution": "def is_sublist(l, s):\n\tif len(l) < len(s):\n\t\treturn False\n\treturn any(l[i:i+len(s)] == s for i in range(len(l)-len(s)+1))", "input_output_examples": "[[[[2, 4, 3, 5, 7], [3, 7]]], [[False]]]", "starter_code": "from typing import List\ndef is_sublist(l: List[int], s: List[int]) -> bool:", "llm_generated_inputs": {"deepseek-v3": "[[[2, 4, 3, 5, 7], [3, 5]], [[2, 4, 3, 5, 7], [3, 7]], [[1, 2, 3, 4, 5], [1, 2, 3]], [[1, 2, 3, 4, 5], [2, 3, 4]], [[1, 2, 3, 4, 5], [5]], [[1, 2, 3, 4, 5], [6]], [[1, 2, 3, 4, 5], []], [[], [1, 2]], [[], []], [[1, 1, 1, 2, 2], [1, 1, 2]], [[1, 1, 1, 2, 2], [1, 2, 2]], [[1, 2, 3, 4, 5], [1, 2, 3, 4, 5]], [[1, 2, 3, 4, 5], [1, 2, 3, 4, 5, 6]], [[1, 2, 3, 4, 5], [1, 3, 5]], [[1, 2, 3, 4, 5], [1, 3, 2]]]", "qwen2.5-coder-32b-instruct": "[[[2, 4, 3, 5, 7], [3, 7]], [[1, 2, 3, 4, 5], [2, 3]], [[1, 2, 3, 4, 5], [5]], [[1, 2, 3, 4, 5], [1]], [[1, 2, 3, 4, 5], []], [[1, 2, 3, 4, 5], [6]], [[1, 2, 3, 4, 5], [1, 2, 3, 4, 5]], [[1, 2, 3, 4, 5], [2, 4, 5]], [[1, 2, 2, 3, 4], [2, 2]], [[1, 2, 3, 4, 5], [5, 4]]]", "gpt-4o-mini": "[[[1, 2, 3, 4], [2, 3]], [[1, 2, 3, 4], [5, 6]], [[1, 2, 3, 4, 5, 6], [1, 2, 3]], [[1, 1, 1, 1], [1, 1]], [[1, 2, 3, 4], []], [[], [1]], [[], []], [[5, 6, 7], [6, 7]], [[0, 1, 2, 3], [1, 2, 3, 4]], [[10, 20, 30], [30]]]"}}
{"task_id": "Mbpp/70", "requirement": "from typing import List\nfrom typing import Tuple\n\n\ndef get_equal(Input: List[Tuple]) -> bool:\n\"\"\"\nWrite a function to find whether all the given tuples have equal length or not.\n\"\"\"", "entry_point": "get_equal", "canonical_solution": "def get_equal(Input):\n  return len(set(len(item) for item in Input)) == 1", "input_output_examples": "[[[[(11, 22, 33), (44, 55, 66)]]], [[True]]]", "starter_code": "from typing import List\nfrom typing import Tuple\ndef get_equal(Input: List[Tuple]) -> bool:", "llm_generated_inputs": {"deepseek-v3": "[[[(1, 2, 3), (4, 5, 6)]], [[(1, 2), (3, 4), (5, 6)]], [[(1,), (2,), (3,)]], [[(1, 2, 3), (4, 5), (6, 7, 8)]], [[]], [[(1, 2, 3)]], [[(1, 2, 3), (4, 5, 6), (7, 8, 9, 10)]], [[(1,), (2, 3), (4, 5, 6)]]]", "qwen2.5-coder-32b-instruct": "[[[(11, 22, 33), (44, 55, 66)]], [[(1, 2), (3, 4, 5)]], [[(1,), (2,), (3,)]], [[]], [[(1, 2, 3), (4, 5, 6), (7, 8, 9)]], [[(1, 2, 3), (4, 5), (6, 7, 8, 9)]], [[(1, 2, 3), (1, 2, 3), (1, 2, 3)]]]", "gpt-4o-mini": "[[[(1, 2), (3, 4), (5, 6)]], [[(1, 2, 3), (4, 5, 6), (7, 8, 9)]], [[(1,), (2,), (3,)]], [[(1, 2), (3, 4, 5)]], [[(), (), ()]], [[(1, 2), (3, 4), (5, 6, 7)]]]"}}
{"task_id": "Mbpp/71", "requirement": "from typing import List\n\n\ndef comb_sort(nums: List[int]) -> List[int]:\n\"\"\"\nWrite a function to sort a list of elements.\n\"\"\"", "entry_point": "comb_sort", "canonical_solution": "def comb_sort(nums):\n    n = len(nums)\n    gap = n\n    shrink = 1.3\n    swapped = True\n    while gap > 1 or swapped:\n        gap = int(gap / shrink)\n        if gap < 1:\n            gap = 1\n        swapped = False\n        for i in range(n - gap):\n            if nums[i] > nums[i + gap]:\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swapped = True\n    return nums", "input_output_examples": "[[[[5, 15, 37, 25, 79]]], [[[5, 15, 25, 37, 79]]]]", "starter_code": "from typing import List\ndef comb_sort(nums: List[int]) -> List[int]:", "llm_generated_inputs": {"deepseek-v3": "[[[5, 15, 37, 25, 79]], [[1, 2, 3, 4, 5]], [[5, 4, 3, 2, 1]], [[42]], [[]], [[10, 9, 8, 7, 6, 5, 4, 3, 2, 1]], [[3, 6, 8, 10, 1, 2, 1]], [[-5, -1, -3, -2, -4]], [[0, 0, 0, 0]], [[1000000, 1, 999999, 2, 999998]]]", "qwen2.5-coder-32b-instruct": "[[[5, 15, 37, 25, 79]], [[10, 9, 8, 7, 6, 5, 4, 3, 2, 1]], [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]], [[5]], [[]], [[3, 3, 3, 3, 3]], [[100, -100, 50, -50, 0]]]", "gpt-4o-mini": "[[[5, 3, 8, 4, 2]], [[1]], [[]], [[10, -1, 2, 4, 3]], [[3, 2, 1]], [[7, 7, 7, 7]], [[5, 1, 4, 2, 3, 6]], [[100, 23, 5, 67, 89, 0]], [[-10, -1, -5]], [[1, 2, 3, 4, 5]]]"}}
{"task_id": "Mbpp/72", "requirement": "def dif_Square(n: int) -> bool:\n\"\"\"\nWrite a python function to check whether the given number can be represented as the difference of two squares or not.\n\"\"\"", "entry_point": "dif_Square", "canonical_solution": "def dif_Square(n): \n    # see https://www.quora.com/Which-numbers-can-be-expressed-as-the-difference-of-two-squares\n    return n % 4 != 2", "input_output_examples": "[[[5]], [[True]]]", "starter_code": "def dif_Square(n: int) -> bool:", "llm_generated_inputs": {"deepseek-v3": "[[5], [16], [3], [0], [-1], [1], [13], [25], [100], [7]]", "qwen2.5-coder-32b-instruct": "[[5], [3], [0], [1], [2], [4], [9], [15], [16], [-1], [-5]]", "gpt-4o-mini": "[[1], [0], [4], [9], [15], [16], [25], [-1], [2], [8]]"}}
{"task_id": "Mbpp/74", "requirement": "from typing import List\n\n\ndef is_samepatterns(colors: List[str], patterns: List[str]) -> bool:\n\"\"\"\nWrite a function to check whether it follows the sequence given in the patterns array.\n\"\"\"", "entry_point": "is_samepatterns", "canonical_solution": "def is_samepatterns(colors, patterns):    \n    if len(colors) != len(patterns):\n        return False    \n    pattern_color_dict = {pattern: set() for pattern in patterns}\n    for color, pattern in zip(colors, patterns):\n        pattern_color_dict[pattern].add(color)\n    return all(len(pattern_color_dict[pattern]) == 1 for pattern in patterns)", "input_output_examples": "[[[['red', 'green', 'green'], ['a', 'b', 'b']]], [[True]]]", "starter_code": "from typing import List\ndef is_samepatterns(colors: List[str], patterns: List[str]) -> bool:", "llm_generated_inputs": {"deepseek-v3": "[[['red', 'green', 'green'], ['a', 'b', 'b']], [['blue', 'blue', 'blue'], ['x', 'x', 'x']], [['yellow', 'red', 'yellow'], ['a', 'b', 'a']], [['purple', 'orange', 'purple', 'orange'], ['c', 'd', 'c', 'd']], [['black', 'white', 'black'], ['x', 'y', 'z']], [['green', 'green', 'blue'], ['a', 'a', 'a']], [['red', 'green', 'blue'], ['a', 'b', 'c']], [[], []], [['red'], ['a']], [['red', 'green', 'blue'], ['a', 'b', 'b']]]", "qwen2.5-coder-32b-instruct": "[[['red', 'green', 'green'], ['a', 'b', 'b']], [['red', 'green', 'blue'], ['a', 'b', 'c']], [['red', 'red', 'red'], ['a', 'a', 'a']], [['red', 'green'], ['a', 'b']], [[], []], [['red'], ['a']], [['red', 'green', 'green'], ['a', 'b', 'c']], [['red', 'green', 'blue', 'blue'], ['a', 'b', 'c', 'c']], [['red', 'green', 'blue'], ['a', 'a', 'a']]]", "gpt-4o-mini": "[[['red', 'blue', 'green'], ['A', 'B', 'C']], [['red', 'blue', 'green'], ['A', 'A', 'B']], [[], []], [['red'], ['A']], [['red', 'blue', 'green'], ['A', 'B']], [['red', 'blue', 'green'], ['A', 'B', 'B']], [['red', 'red', 'blue'], ['A', 'A', 'B']], [['blue', 'blue'], ['A', 'A']], [['yellow', 'yellow', 'blue'], ['A', 'B', 'B']]]"}}
{"task_id": "Mbpp/75", "requirement": "from typing import List\nfrom typing import Tuple\n\n\ndef find_tuples(test_list: List[Tuple[int, ...]], K: int) -> List[Tuple[int, ...]]:\n\"\"\"\nWrite a function to find tuples which have all elements divisible by k from the given list of tuples.\n\"\"\"", "entry_point": "find_tuples", "canonical_solution": "def find_tuples(test_list, K):\n  res = [sub for sub in test_list if all(ele % K == 0 for ele in sub)]\n  return res", "input_output_examples": "[[[[(6, 24, 12), (7, 9, 6), (12, 18, 21)], 6]], [[[(6, 24, 12)]]]]", "starter_code": "from typing import List\nfrom typing import Tuple\ndef find_tuples(test_list: List[Tuple[int, ...]], K: int) -> List[Tuple[int, ...]]:", "llm_generated_inputs": {"deepseek-v3": "[[[(6, 24, 12), (7, 9, 6), (12, 18, 21)], 6], [[(10, 20, 30), (15, 25, 35), (40, 50, 60)], 5], [[(3, 9, 12), (4, 8, 16), (5, 10, 15)], 3], [[(1, 2, 3), (4, 5, 6), (7, 8, 9)], 1], [[(0, 0, 0), (1, 1, 1), (2, 2, 2)], 2], [[(11, 22, 33), (44, 55, 66), (77, 88, 99)], 11], [[(100, 200), (300, 400), (500, 600)], 100], [[], 5], [[(5, 10, 15), (20, 25, 30), (35, 40, 45)], 0]]", "qwen2.5-coder-32b-instruct": "[[[(6, 24, 12), (7, 9, 6), (12, 18, 21)], 6], [[(3, 9, 15), (10, 20, 30), (14, 28, 42)], 3], [[(5, 10, 15), (20, 25, 30), (35, 40, 45)], 5], [[(1, 2, 3), (4, 5, 6), (7, 8, 9)], 1], [[(8, 16, 24), (10, 20, 30), (12, 24, 36)], 4], [[(2, 4, 6), (3, 6, 9), (5, 10, 15)], 2], [[], 5], [[(0, 0, 0), (0, 1, 2), (3, 0, 6)], 0], [[(10, 20, 30), (15, 25, 35), (20, 40, 60)], 10], [[(11, 22, 33), (22, 44, 66), (33, 66, 99)], 11]]", "gpt-4o-mini": "[[[(2, 4, 6), (1, 3, 5), (8, 10, 12), (18, 24), (9, 15)], 2], [[(10, 20), (25, 30, 35), (5, 10), (7, 14)], 5], [[(3, 6, 9), (1, 1), (10, 5)], 3], [[(4,), (8, 16, 32), (5, 7)], 4], [[(), (7, 14, 21), (2,)], 7], [[(10, 15, 20), (9, 12)], 1], [[(1, 2, 3), (4, 5, 6), (7, 8, 9)], 10], [[], 3]]"}}
{"task_id": "Mbpp/77", "requirement": "def is_Diff(n: int) -> bool:\n\"\"\"\nWrite a python function to find whether a number is divisible by 11.\n\"\"\"", "entry_point": "is_Diff", "canonical_solution": "def is_Diff(n): \n    return n % 11 == 0", "input_output_examples": "[[[12345]], [[False]]]", "starter_code": "def is_Diff(n: int) -> bool:", "llm_generated_inputs": {"deepseek-v3": "[[12345], [121], [0], [11], [22], [123456789], [12345678], [-121], [-12345]]", "qwen2.5-coder-32b-instruct": "[[12345], [0], [11], [-11], [22], [-22], [1001], [-1001], [121], [-121], [9], [-9], [123456789], [-123456789]]", "gpt-4o-mini": "[[0], [11], [22], [10], [33], [-11], [-22], [5], [101], [123456789]]"}}
{"task_id": "Mbpp/79", "requirement": "def word_len(s: str) -> bool:\n\"\"\"\nWrite a python function to check whether the length of the word is odd or not.\n\"\"\"", "entry_point": "word_len", "canonical_solution": "def word_len(s): \n    return len(s) % 2 == 1", "input_output_examples": "[[['Hadoop']], [[False]]]", "starter_code": "def word_len(s: str) -> bool:", "llm_generated_inputs": {"deepseek-v3": "[['Hadoop'], ['Python'], ['Java'], ['C++'], ['a'], [''], ['abcdefghijklmnopqrstuvwxyz'], ['1234567890'], ['!@#$%^&*()'], [' ']]", "qwen2.5-coder-32b-instruct": "[['Hadoop'], ['Python'], ['Java'], ['R'], [''], ['a'], ['OpenAI'], ['ChatGPT']]", "gpt-4o-mini": "[['hello'], ['word'], ['python'], ['abcdefghijklmnopqrstuvwxyz'], [''], ['a'], ['123'], ['!']]"}}
{"task_id": "Mbpp/80", "requirement": "def tetrahedral_number(n: int) -> float:\n\"\"\"\nWrite a function to find the nth tetrahedral number.\n\"\"\"", "entry_point": "tetrahedral_number", "canonical_solution": "def tetrahedral_number(n): \n\treturn (n * (n + 1) * (n + 2)) / 6", "input_output_examples": "[[[5]], [[35]]]", "starter_code": "def tetrahedral_number(n: int) -> float:", "llm_generated_inputs": {"deepseek-v3": "[[5], [1], [10], [0], [-3]]", "qwen2.5-coder-32b-instruct": "[[1], [2], [3], [4], [5], [10], [0], [-1], [-5]]", "gpt-4o-mini": "[[1], [2], [3], [10], [0], [-1], [100], [6]]"}}
{"task_id": "Mbpp/82", "requirement": "def volume_sphere(r: float) -> float:\n\"\"\"\nWrite a function to find the volume of a sphere.\n\"\"\"", "entry_point": "volume_sphere", "canonical_solution": "import math\ndef volume_sphere(r):\n  return (4./3.) * math.pi * (r**3)", "input_output_examples": "[[[10]], [[4188.790204786391]]]", "starter_code": "def volume_sphere(r: float) -> float:", "llm_generated_inputs": {"deepseek-v3": "[[10.0], [0.0], [-5.0], [1.5], [100.0]]", "qwen2.5-coder-32b-instruct": "[[10], [0], [1], [1.5], [2.3], [-1], [-5.5], [100]]", "gpt-4o-mini": "[[1.0], [0.0], [5.0], [10.0], [2.5], [-3.0], [100.0], [3.14159], [1e-10]]"}}
{"task_id": "Mbpp/84", "requirement": "def sequence(n: int) -> int:\n\"\"\"\nWrite a function to find the nth number in the newman conway sequence.\n\"\"\"", "entry_point": "sequence", "canonical_solution": "def sequence(n): \n\tif n == 1 or n == 2: \n\t\treturn 1\n\tseq = [0] * (n + 1)\n\tseq[1] = seq[2] = 1\n\tfor i in range(3, n + 1):\n\t\tseq[i] = seq[seq[i - 1]] + seq[i - seq[i - 1]]\n\treturn seq[n]", "input_output_examples": "[[[10]], [[6]]]", "starter_code": "def sequence(n: int) -> int:", "llm_generated_inputs": {"deepseek-v3": "[[1], [2], [3], [10], [20], [30], [40], [50], [100], [0], [-1]]", "qwen2.5-coder-32b-instruct": "[[1], [2], [3], [4], [5], [6], [7], [8], [9], [10], [11], [12], [13], [14], [15], [0], [-1], [-5]]", "gpt-4o-mini": "[[1], [2], [3], [4], [5], [10], [15], [20], [50], [100]]"}}
{"task_id": "Mbpp/85", "requirement": "def surfacearea_sphere(r: float) -> float:\n\"\"\"\nWrite a function to find the surface area of a sphere.\n\"\"\"", "entry_point": "surfacearea_sphere", "canonical_solution": "import math\ndef surfacearea_sphere(r):\n  return 4 * math.pi * (r**2)", "input_output_examples": "[[[10]], [[1256.6370614359173]]]", "starter_code": "def surfacearea_sphere(r: float) -> float:", "llm_generated_inputs": {"deepseek-v3": "[[10.0], [0.0], [1.0], [100.0], [-5.0]]", "qwen2.5-coder-32b-instruct": "[[10], [0], [1], [1.5], [100], [-1], [-10.5], [0.001], [1000000]]", "gpt-4o-mini": "[[1.0], [0.0], [-1.0], [10.5], [100.0], [3.14], [2.5], [10000000000.0]]"}}
{"task_id": "Mbpp/86", "requirement": "def centered_hexagonal_number(n: int) -> int:\n\"\"\"\nWrite a function to find nth centered hexagonal number.\n\"\"\"", "entry_point": "centered_hexagonal_number", "canonical_solution": "def centered_hexagonal_number(n):\n  return 3 * n * (n - 1) + 1", "input_output_examples": "[[[10]], [[271]]]", "starter_code": "def centered_hexagonal_number(n: int) -> int:", "llm_generated_inputs": {"deepseek-v3": "[[1], [2], [3], [10], [0], [-1], [100]]", "qwen2.5-coder-32b-instruct": "[[1], [2], [3], [4], [5], [10], [0], [-1], [100]]", "gpt-4o-mini": "[[1], [2], [3], [10], [0], [-1]]"}}
{"task_id": "Mbpp/87", "requirement": "def merge_dictionaries_three(dict1: dict, dict2: dict, dict3: dict) -> dict:\n\"\"\"\nWrite a function to merge three dictionaries into a single dictionary.\n\"\"\"", "entry_point": "merge_dictionaries_three", "canonical_solution": "import collections as ct\ndef merge_dictionaries_three(dict1,dict2, dict3):\n    merged_dict = dict(ct.ChainMap({},dict1,dict2,dict3))\n    return merged_dict", "input_output_examples": "[[[{'R': 'Red', 'B': 'Black', 'P': 'Pink'}, {'G': 'Green', 'W': 'White'}, {'O': 'Orange', 'W': 'White', 'B': 'Black'}]], [[{'B': 'Black', 'R': 'Red', 'P': 'Pink', 'G': 'Green', 'W': 'White', 'O': 'Orange'}]]]", "starter_code": "def merge_dictionaries_three(dict1: dict, dict2: dict, dict3: dict) -> dict:", "llm_generated_inputs": {"deepseek-v3": "[[{'a': 1, 'b': 2}, {'c': 3, 'd': 4}, {'e': 5, 'f': 6}], [{'x': 'apple', 'y': 'banana'}, {'z': 'cherry'}, {'x': 'apricot', 'w': 'watermelon'}], [{}, {}, {}], [{'key1': 'value1'}, {'key1': 'value2'}, {'key1': 'value3'}], [{'A': 1, 'B': 2}, {'A': 3, 'C': 4}, {'B': 5, 'C': 6}], [{'a': {'nested': 1}}, {'b': {'nested': 2}}, {'a': {'nested': 3}}], [{'a': [1, 2]}, {'b': [3, 4]}, {'a': [5, 6]}]]", "qwen2.5-coder-32b-instruct": "[[{'R': 'Red', 'B': 'Black', 'P': 'Pink'}, {'G': 'Green', 'W': 'White'}, {'O': 'Orange', 'W': 'White', 'B': 'Black'}], [{}, {}, {}], [{'key1': 'value1'}, {'key2': 'value2'}, {'key3': 'value3'}], [{'a': 1, 'b': 2}, {'b': 3, 'c': 4}, {'c': 5, 'd': 6}], [{'x': 'one'}, {}, {'x': 'two'}], [{'same': 'value'}, {'same': 'value'}, {'same': 'value'}]]", "gpt-4o-mini": "[[{'a': 1}, {'b': 2}, {'c': 3}], [{'key1': 'value1'}, {'key2': 'value2'}, {'key1': 'value3'}], [{}, {}, {}], [{'shared': 1}, {'shared': 2}, {'shared': 3}], [{'single_key': 'single_value'}, {}, {'another_key': 'another_value'}], [{'a': 1, 'b': 2}, {'b': 3, 'c': 4}, {'d': 5}]]"}}
{"task_id": "Mbpp/88", "requirement": "from typing import List\nfrom typing import Dict\n\n\ndef freq_count(list1: List[Any]) -> Dict[Any, int]:\n\"\"\"\nWrite a function to get the frequency of all the elements in a list, returned as a dictionary.\n\"\"\"", "entry_point": "freq_count", "canonical_solution": "import collections\ndef freq_count(list1):\n  freq_count= collections.Counter(list1)\n  return freq_count", "input_output_examples": "[[[[10, 10, 10, 10, 20, 20, 20, 20, 40, 40, 50, 50, 30]]], [[{10: 4, 20: 4, 40: 2, 50: 2, 30: 1}]]]", "starter_code": "from typing import List\nfrom typing import Dict\ndef freq_count(list1: List[Any]) -> Dict[Any, int]:", "llm_generated_inputs": {"deepseek-v3": "[[[10, 10, 10, 10, 20, 20, 20, 20, 40, 40, 50, 50, 30]], [[1, 2, 3, 4, 5]], [[1, 1, 1, 1, 1]], [[]], [['a', 'b', 'a', 'c', 'b', 'a']], [[True, False, True, True, False]], [[1.1, 2.2, 1.1, 3.3, 2.2, 1.1]], [[None, None, 1, 2, 1, None]], [[[1, 2], [1, 2], [3, 4], [1, 2]]]]", "qwen2.5-coder-32b-instruct": "[[[10, 10, 10, 10, 20, 20, 20, 20, 40, 40, 50, 50, 30]], [[1, 2, 2, 3, 3, 3, 4, 4, 4, 4]], [['a', 'b', 'c', 'a', 'b', 'a']], [[]], [[1]], [[None, None, 1, 1, 'a', 'a']], [[True, False, True, True]]]", "gpt-4o-mini": "[[[1, 2, 2, 3, 1, 4]], [['apple', 'banana', 'apple', 'orange', 'banana', 'banana']], [['a', 'b', 'a', 'b', 'a', 'c']], [[True, False, True, True, False]], [['', '', 'hello', 'world', 'hello']], [[]], [['single']], [[1, 1, 1, 1, 1]], [[None, None, None]]]"}}
{"task_id": "Mbpp/89", "requirement": "def closest_num(N: int) -> int:\n\"\"\"\nWrite a function to find the closest smaller number than n.\n\"\"\"", "entry_point": "closest_num", "canonical_solution": "def closest_num(N):\n  return (N - 1)", "input_output_examples": "[[[11]], [[10]]]", "starter_code": "def closest_num(N: int) -> int:", "llm_generated_inputs": {"deepseek-v3": "[[11], [1], [100], [0], [-5], [2], [-1]]", "qwen2.5-coder-32b-instruct": "[[11], [1], [0], [-1], [-10], [100], [999]]", "gpt-4o-mini": "[[10], [1], [0], [-5], [-1], [100], [50], [2]]"}}
{"task_id": "Mbpp/90", "requirement": "from typing import List\n\n\ndef len_log(list1: List[str]) -> int:\n\"\"\"\nWrite a python function to find the length of the longest word.\n\"\"\"", "entry_point": "len_log", "canonical_solution": "def len_log(list1):\n    return max(len(x) for x in list1)", "input_output_examples": "[[[['python', 'PHP', 'bigdata']]], [[7]]]", "starter_code": "from typing import List\ndef len_log(list1: List[str]) -> int:", "llm_generated_inputs": {"deepseek-v3": "[[['python', 'PHP', 'bigdata']], [['a', 'bb', 'ccc', 'dddd']], [['', ' ', '  ', '   ']], [['hello', 'world', 'python']], [[]], [['single']], [['longestword', 'short', 'medium']], [['123456789', '123', '123456']]]", "qwen2.5-coder-32b-instruct": "[[['python', 'PHP', 'bigdata']], [['a', 'ab', 'abc']], [['longestword', 'short', 'tiny']], [[]], [['equal', 'equal', 'equal']], [['single']], [['', 'nonempty', 'string']], [['verylongwordindeed', 'short', 'tiny']]]", "gpt-4o-mini": "[[['apple', 'banana', 'cherry', 'date', 'elderberry']], [['short', 'tiny']], [['longestword', 'medium', 'small']], [['a', 'ab', 'abc', 'abcd', 'abcde']], [['', 'single', 'words', 'in', 'the', 'list']], [['cat', 'dog', 'elephant', 'tiger']], [['unicode', '漢字', '日本語', '😊']], [['', '']], [['oneword']]]"}}
{"task_id": "Mbpp/91", "requirement": "from typing import List\n\n\ndef find_substring(str1: List[str], sub_str: str) -> bool:\n\"\"\"\nWrite a function to check if a string is present as a substring in a given list of string values.\n\"\"\"", "entry_point": "find_substring", "canonical_solution": "def find_substring(str1, sub_str):\n   return any(sub_str in s for s in str1)", "input_output_examples": "[[[['red', 'black', 'white', 'green', 'orange'], 'ack']], [[True]]]", "starter_code": "from typing import List\ndef find_substring(str1: List[str], sub_str: str) -> bool:", "llm_generated_inputs": {"deepseek-v3": "[[['red', 'black', 'white', 'green', 'orange'], 'ack'], [['apple', 'banana', 'cherry'], 'ana'], [['hello', 'world'], 'xyz'], [['', 'abc', 'def'], ''], [['abc', '', 'def'], 'abc'], [['abc', 'def', 'ghi'], 'jkl'], [['abc', 'abc', 'abc'], 'abc'], [['a', 'b', 'c'], 'a'], [['longword', 'short', 'medium'], 'medium'], [['case', 'sensitive', 'test'], 'Case']]", "qwen2.5-coder-32b-instruct": "[[['red', 'black', 'white', 'green', 'orange'], 'ack'], [['red', 'black', 'white', 'green', 'orange'], 'blue'], [[], 'ack'], [['red', 'black', 'white', 'green', 'orange'], ''], [['red', 'black', 'white', 'green', 'orange'], 'orange'], [['red', 'black', 'white', 'green', 'orange'], 'red'], [['red', 'black', 'white', 'green', 'orange'], 'e'], [['red', 'black', 'white', 'green', 'orange'], 'z']]", "gpt-4o-mini": "[[['hello', 'world', 'foo', 'bar'], 'world'], [['apple', 'banana', 'orange'], 'grape'], [['test', 'find', 'substring'], 'find'], [['case', 'sensitive', 'test'], 'sensitive'], [[], 'empty'], [['single'], 'single'], [['duplicate', 'duplicate'], 'duplicate'], [['leading', 'edges'], 'edges']]"}}
{"task_id": "Mbpp/92", "requirement": "def is_undulating(n: int) -> bool:\n\"\"\"\nWrite a function to check whether the given number is undulating or not.\n\"\"\"", "entry_point": "is_undulating", "canonical_solution": "def is_undulating(n): \n\tdigits = [int(digit) for digit in str(n)]\n\tif len(set(digits)) != 2:\n\t\treturn False\n\treturn all(a != b for a, b in zip(digits, digits[1:]))", "input_output_examples": "[[[1212121]], [[True]]]", "starter_code": "def is_undulating(n: int) -> bool:", "llm_generated_inputs": {"deepseek-v3": "[[1212121], [1232123], [131313], [12345], [111111], [121], [12], [1], [0], [123123123]]", "qwen2.5-coder-32b-instruct": "[[1212121], [123123], [787878], [121], [12], [1], [101010], [1001], [989898], [111], [222], [12321], [45654], [112211], [1221]]", "gpt-4o-mini": "[[121], [123], [12123], [232], [12321], [0], [1], [10], [22], [1210], [111]]"}}
{"task_id": "Mbpp/93", "requirement": "def power(a: int, b: int) -> int:\n\"\"\"\nWrite a function to calculate the value of 'a' to the power 'b'.\n\"\"\"", "entry_point": "power", "canonical_solution": "def power(a, b):\n\treturn a ** b", "input_output_examples": "[[[3, 4]], [[81]]]", "starter_code": "def power(a: int, b: int) -> int:", "llm_generated_inputs": {"deepseek-v3": "[[3, 4], [2, 5], [5, 0], [-2, 3], [-3, 2], [0, 0], [1, 100], [10, -1], [-1, 4], [-1, 3]]", "qwen2.5-coder-32b-instruct": "[[3, 4], [2, 3], [5, 0], [0, 5], [0, 0], [-2, 3], [-2, 2], [2, -3], [-2, -3], [10, 1], [1, 10]]", "gpt-4o-mini": "[[2, 3], [5, 0], [10, -1], [3, 2], [4, 0], [0, 5], [1, 100], [-2, 3], [-3, 2], [0, 0]]"}}
{"task_id": "Mbpp/94", "requirement": "from typing import List\n\n\ndef index_minimum(test_list: List[tuple]) -> any:\n\"\"\"\nGiven a list of tuples, write a function that returns the first value of the tuple with the smallest second value.\n\"\"\"", "entry_point": "index_minimum", "canonical_solution": "from operator import itemgetter \ndef index_minimum(test_list):\n  res = min(test_list, key = itemgetter(1))[0]\n  return (res)", "input_output_examples": "[[[[('Rash', 143), ('Manjeet', 200), ('Varsha', 100)]]], [['Varsha']]]", "starter_code": "from typing import List\ndef index_minimum(test_list: List[tuple]) -> any:", "llm_generated_inputs": {"deepseek-v3": "[[[('Rash', 143), ('Manjeet', 200), ('Varsha', 100)]], [[('Alice', 50), ('Bob', 30), ('Charlie', 70)]], [[('X', 10), ('Y', 10), ('Z', 5)]], [[('A', 1000), ('B', 100), ('C', 100), ('D', 50)]], [[('One', -10), ('Two', 0), ('Three', 10)]], [[('First', 1)]], [[]], [[('Same', 5), ('Same', 5), ('Same', 5)]]]", "qwen2.5-coder-32b-instruct": "[[[('Rash', 143), ('Manjeet', 200), ('Varsha', 100)]], [[('Alice', 5), ('Bob', 2), ('Charlie', 8)]], [[('Tom', 10), ('Jerry', 10), ('Spike', 5)]], [[('One', 1)]], [[('First', 3), ('Second', 2), ('Third', 1)]], [[('A', 100), ('B', 200), ('C', 50), ('D', 50)]], [[('Single', 0)]], [[]]]", "gpt-4o-mini": "[[[('a', 5), ('b', 3), ('c', 10)]], [[('apple', 2), ('banana', 3), ('cherry', 1)]], [[('x', -1), ('y', -2), ('z', -3)]], [[('one', 1)]], [[('first', 10), ('second', 10), ('third', 10)]], [[(1, 5), (2, 3), (3, 2), (4, 1)]]]"}}
{"task_id": "Mbpp/95", "requirement": "from typing import List\n\n\ndef Find_Min_Length(lst: List[List[Any]]) -> int:\n\"\"\"\nWrite a python function to find the length of the smallest list in a list of lists.\n\"\"\"", "entry_point": "Find_Min_Length", "canonical_solution": "def Find_Min_Length(lst):  \n    minLength = min(len(x) for x in lst )\n    return minLength", "input_output_examples": "[[[[[1], [1, 2]]]], [[1]]]", "starter_code": "from typing import List\ndef Find_Min_Length(lst: List[List[Any]]) -> int:", "llm_generated_inputs": {"deepseek-v3": "[[[[1], [1, 2]]], [[[], [1, 2, 3]]], [[[1, 2, 3], [4, 5], [6]]], [[[1], [2], [3], [4]]], [[[1, 2, 3, 4], [5, 6], [7, 8, 9]]], [[[], [], []]], [[[1, 2, 3], [4, 5], [6, 7, 8, 9], [10]]], [[[1], [1]]]]", "qwen2.5-coder-32b-instruct": "[[[[1], [1, 2]]], [[[1, 2, 3], [4, 5], [6]]], [[]], [[[], [1, 2], [3, 4, 5]]], [[[1, 2, 3], [4, 5, 6], [7, 8, 9]]], [[[1]]], [[[1], [2], [3]]]]", "gpt-4o-mini": "[[[[], [], []]], [[[1, 2], [3, 4, 5], [6]]], [[[1], [2, 3, 4, 5], [6, 7]]], [[[1, 2, 3], [4], [5, 6, 7, 8]]], [[[1], [], [2]]], [[[1], [2], [3], [4], [5]]], [[[0], [0, 0, 0], [0, 0]]], [[[1, 2, 3, 4], [5, 6], [7, 8, 9]]]]"}}
{"task_id": "Mbpp/96", "requirement": "def divisor(n: int) -> int:\n\"\"\"\nWrite a python function to find the number of divisors of a given integer.\n\"\"\"", "entry_point": "divisor", "canonical_solution": "def divisor(n):\n  return sum(1 for i in range(1, n + 1) if n % i == 0)", "input_output_examples": "[[[15]], [[4]]]", "starter_code": "def divisor(n: int) -> int:", "llm_generated_inputs": {"deepseek-v3": "[[1], [2], [15], [16], [17], [100], [0], [-10], [2147483647]]", "qwen2.5-coder-32b-instruct": "[[15], [1], [0], [-5], [16], [13]]", "gpt-4o-mini": "[[1], [12], [100], [13], [0], [-15], [25], [7], [16]]"}}
